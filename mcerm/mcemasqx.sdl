MASTER PROCESS mcemas
  COMMENT '%SID%';
/*
 *  Author: Inderjeet 
 *
 *  Environment:
 *      rnxsysqx,rnqsybqx,ceisebqx
 *
 *  Description:
 *      Master process of MCERMI
 *
 *  COPYRIGHT (c) 2000 - 2010 NSN
 *
 **************************************************************************/

DCL WITHWARMING
    G_pce_pid                 pid_union_t,
    G_ste_pid                 pid_union_t,
    G_pce_attr                attr_group_t,
    G_c1_file_handle          file_handle_t(FILE_WARMED_ENTIRELY,c1file_fn),
    G_c1_hash_file_handle     file_handle_t(FILE_WARMED_ENTIRELY,c1hash_fn),
    G_pcermi_status           error_t,
    G_c1file_open_status      bool,
    G_dekfil_open_status      bool;
DCL
    mceha2_pid           pid_union_t,
    serv_add_done           bool := F,
    init_done               bool := F,
    subscription_done       error_t := no_such_file_ec,
    np_recov_feature_status word := 0,
    dsp_sample_interval_count word := 0,
    rrc_conn_setup_thd_mgn word := 0,
    cs_rab_setup_thd_mgn word := 0,
    ps_rab_setup_thd_mgn word := 0,
    pkt_call_setup_thd_mgn word := 0,
    pkt_call_rel_thd_mgn word := 0,
    rab_call_rel_thd_mgn word := 0,
    np_recov_init_done bool := F;
           
TIMER
    master_timer            = 0x9A00,
    t_c1file_update_timer   = 0x9A01,
    t_data_collect_timer    = 0x9A03,    /* DATA collection stop Timer */
    t_hand_supervision      = 0x9B09,
    t_wait_supervision      = 0x9B10, 
    t_wait_upd_retry_time   = 0x9B04;
    

#include "mcema1qx.sdl"

/* Procedure Definition ***************************************************/

PROCEDURE get_pce_pid;

/* Return parameters ******************************************************/

RETURNS error_t;

/* Variable definitions ***************************************************/
DCL
    l_status        error_t;

/* Procedure Body *********************************************************/
START;

    TASK l_status := success_ec;

    DECISION (G_pce_pid.real_pid = NULL);
    (T):
        TASK l_status := get_service_r('cerm_data_collecting_as',
                                       G_pce_pid.real_pid,G_pce_attr);
        DECISION l_status;
        (/=success_ec):
            TASK write_test_log(log_type_t_dword_e_c,bytepointer(@l_status),1,
                                @'MCEMAS: get_pce_pid fail');

            TASK G_pce_pid.real_pid := NULL;
        ENDDECISION;
    ENDDECISION;

    RETURN l_status;

ENDPROCEDURE get_pce_pid;

/**********************************************************/
PROCEDURE init_mce_for_celldata;
DCL
    l_status                error_t,
    l_next_update_period    dword := 0,
    l_cerm_status           cerm_status__t := 0;

START;

    TASK set_c1file_update_period(c1file_update_period_c);
    TASK set_pcermi_report_period(pcermi_report_period_c);
    
    CREATE mceste;
    TASK G_ste_pid.real_pid := OFFSPRING;

    DECISION G_pcermi_status;
    (/=success_ec):
        TASK G_pcermi_status := get_pce_pid();   /*inquire PCERMI Services */
    ENDDECISION;
    
    DECISION read_prfile(pr_cl_t_system_funct_configur/*002,ZWOI:2,1866;*/, pr_nr_t_cerm_conf_data/*1866*/, l_cerm_status);
    (F):
         TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                      @'MCEMAS: read collecting celldata prfile  failed'); 
        DECISION read_prfile(pr_cl_t_system_funct_configur, pr_nr_t_cerm_conf_data, l_cerm_status);
        (F):      
            TASK write_test_log( log_type_t_empty_t_c,NIL,0,
                                @'MCEMAS: read collecting celldata prfile retry failed ');
            /*
            SET (NOW,master_timer);
            NEXTSTATE cold COMMENT 'comment by YHJ, should not go to cold, need go on for RAN3389 feature';
            */
            RETURN;
        ENDDECISION;
    ENDDECISION;
        
    TASK fill_default_cerm_conf_data();

    DECISION mark_selective_features_on(l_cerm_status);  /*set CERM fetaures ON*/
    (F):
        TASK write_test_log( log_type_t_empty_t_c,NIL,0,
                            @'MCEMAS: collect celldata feature off');
        RETURN;
    ENDDECISION;    
    
    DECISION G_c1file_open_status;
    (F):
        DECISION initialize_c1file();  /*Open C1file*/
        (/=success_ec):
            TASK write_test_log( log_type_t_empty_t_c,NIL,0,
                                @'MCEMAS: C1FILE could not be opened');
             /* COMMENT by YHJ. No need to retry to cause stuck here, PROCESS still needs to handle "tii_req_s' message. */
            /*SET (NOW + name_serv_retry_delay__c,master_timer); */  /*retry after given time delay*/
            /*NEXTSTATE -;' */
            RETURN; 
        ELSE:
            TASK G_c1file_open_status := T;
            TASK l_next_update_period   := get_c1file_update_timer_value();
            SET (NOW + l_next_update_period, t_c1file_update_timer);
        ENDDECISION;
    ENDDECISION;
    DECISION G_dekfil_open_status;
    (F):
        DECISION open_dekfile(access_mode_t_rd_only_c);   /*Open dekfile*/
        (/=success_ec):
            TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                                @'MCEMAS: DEKFILE could not be opened'); 
            /* COMMENT by YHJ. No need to retry to cause stuck here, PROCESS need to wait to handle "tii_req_s' message. */  
            /*SET (NOW + name_serv_retry_delay__c,master_timer);
            NEXTSTATE -; */
            RETURN;
        ELSE:
           TASK G_dekfil_open_status := T;
        ENDDECISION;
    ENDDECISION;
    
    TASK l_status := order_family_restart_notice_r(
                            /*computer_t_width_wo_c*/ G_pce_pid.pid_struct.computer, pcermi_p, SELF );
    
    TASK write_test_log(log_type_t_dword_e_c,bytepointer(@l_status),1,
                      @'MCEMAS: waiting for PCERMI conf data request');

    TASK init_done := T;
    /* COMMENT by YHJ. master_timer was comment out in wait_for_pcermi_status state, so no need to signal this timer now. */
    /* SET (NOW + conf_data_wait_time__c,master_timer); */ 
ENDPROCEDURE init_mce_for_celldata;

/* *********************************************************/
PROCEDURE init_mce_for_3389;
DCL
    l_status                error_t;
START;

    TASK write_test_log(log_type_t_dword_e_c, bytepointer(@l_status),1, @'MCEMAS: Enter in init_mce_for_3389'); /*for debug*/
    
    DECISION(read_prfile(pr_cl_t_system_funct_configur, pr_nr_t_cerm_conf_data, np_recov_feature_status)) COMMENT 'for main funcationality';
    (F):
        TASK write_test_log(log_type_t_dword_e_c, bytepointer(@l_status),1, @'MCEMAS: read prfile for np_recov_feature_status failed');
        RETURN;
    ENDDECISION;

    /* for debug
    DECISION(bit_and_r(np_recov_feature_status, 0x1)); 
    (0):
        RETURN; 
    ENDDECISION;
    */

    DECISION(read_prfile(pr_cl_t_system_funct_configur, pr_nr_t_cerm_conf_data, dsp_sample_interval_count)); 
    (F):
        TASK write_test_log(log_type_t_dword_e_c, bytepointer(@l_status),1, @'MCEMAS: read prfile for dsp_sample_interval_count failed');
        RETURN;
    ENDDECISION;
    
    DECISION(read_prfile(pr_cl_t_system_funct_configur, pr_nr_t_cerm_conf_data, rrc_conn_setup_thd_mgn)); 
    (F):
        TASK write_test_log(log_type_t_dword_e_c, bytepointer(@l_status),1, @'MCEMAS: read prfile for dsp_rrc_conn_setup_thd_mgn failed');
        RETURN;
    ENDDECISION;
    
    DECISION(read_prfile(pr_cl_t_system_funct_configur, pr_nr_t_cerm_conf_data, cs_rab_setup_thd_mgn)); 
    (F):
        TASK write_test_log(log_type_t_dword_e_c, bytepointer(@l_status),1, @'MCEMAS: read prfile for dsp_cs_rab_setup_thd_mgn failed');
        RETURN;
    ENDDECISION;
    
    DECISION(read_prfile(pr_cl_t_system_funct_configur, pr_nr_t_cerm_conf_data, ps_rab_setup_thd_mgn)); 
    (F):
        TASK write_test_log(log_type_t_dword_e_c, bytepointer(@l_status),1, @'MCEMAS: read prfile for dsp_ps_rab_setup_thd_mgn failed');
        RETURN;
    ENDDECISION;
    
    DECISION(read_prfile(pr_cl_t_system_funct_configur, pr_nr_t_cerm_conf_data, pkt_call_setup_thd_mgn)); 
    (F):
        TASK write_test_log(log_type_t_dword_e_c, bytepointer(@l_status),1, @'MCEMAS: read prfile for dsp_pkt_call_setup_thd_mgn failed');
        RETURN;
    ENDDECISION;
    
    DECISION(read_prfile(pr_cl_t_system_funct_configur, pr_nr_t_cerm_conf_data, pkt_call_rel_thd_mgn)); 
    (F):
        TASK write_test_log(log_type_t_dword_e_c, bytepointer(@l_status),1, @'MCEMAS: read prfile for dsp_pkt_call_rel_thd_mgn failed');
        RETURN;
    ENDDECISION;
    
    DECISION(read_prfile(pr_cl_t_system_funct_configur, pr_nr_t_cerm_conf_data, rab_call_rel_thd_mgn)); 
    (F):
        TASK write_test_log(log_type_t_dword_e_c, bytepointer(@l_status),1, @'MCEMAS: read prfile for dsp_rab_call_rel_thd_mgn failed');
        RETURN;
    ENDDECISION;

    CREATE mceha2(dsp_sample_interval_count, rrc_conn_setup_thd_mgn, 
                             cs_rab_setup_thd_mgn, ps_rab_setup_thd_mgn,
                             pkt_call_setup_thd_mgn, pkt_call_rel_thd_mgn ,
                             rab_call_rel_thd_mgn);
    TASK mceha2_pid.real_pid := OFFSPRING;
    
    TASK np_recov_init_done := T;

    /*for debug*/
    TASK dsp_sample_interval_count := 0x1403;
    TASK rrc_conn_setup_thd_mgn := 0x0a0a;
    TASK cs_rab_setup_thd_mgn := 0x0a0a;
    TASK ps_rab_setup_thd_mgn := 0x0a0a;
    TASK pkt_call_setup_thd_mgn := 0x0a0a;
    TASK pkt_call_rel_thd_mgn := 0x0a0a;
    TASK rab_call_rel_thd_mgn := 0x0a0a;
    /* for debug */

    TASK write_test_log(log_type_t_dword_e_c, bytepointer(@l_status),1, @'MCEMAS:  leave init_mce_for_3389'); /*For debug*/
    
ENDPROCEDURE init_mce_for_3389;
/*********************** P R O C E S S    B O D Y *************************/
START;
     
    TASK set_test_log_variables(1); /*YHJ*/
    
    TASK write_test_log( log_type_t_empty_t_c, NIL, 0, @'MCEMAS: starting process');
    TASK G_c1file_open_status := F,
         G_dekfil_open_status := F,
         serv_add_done        := F;
    
    TASK G_pce_pid.real_pid := NULL;
    
    TASK cell_table_init__r();   /*Initialize global cell table for Cell DATA*/
  
    TASK init_mce_hand_tbl();   /*Initialize hand_table*/

    TASK serv_add_done := add_own_services();   /*Register for own service to NASEVA*/
    
    TASK G_pcermi_status := get_pce_pid();   /*inquire PCERMI Services */

    TASK subscription_done := subscribe_state_change_events();   /*subscribe to own unit switchover*/
    
    TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                        @'MCEMAS: Moving to Wait_startup state');

    NEXTSTATE wait_startup;
/**************************************************************************/
STATE wait_startup;

INPUT startup_s(l_mstate,?) COMMENT 'FA81';
DCL
    l_mstate         unit_state_t;
    
    TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                        @'MCEMAS: startup_s');    
                        
    OUTPUT startup_ack_s(success_ec) TO SENDER COMMENT 'FA80';
      
    DECISION(l_mstate);
    (unit_state_t_wo_c):
        TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                            @'MCEMAS: state WO: Moving to init_mce state');
        SET (NOW,master_timer);
        NEXTSTATE init_mce;
    ELSE:
        TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                            @'MCEMAS: Moving to COLD-state');

        SET (NOW,master_timer);
        NEXTSTATE cold;
    ENDDECISION;

INPUT supervision_msg_s(l_mstate,l_sstate,l_phase) COMMENT '0001';

    DCL
        l_mstate    unit_state_t,
        l_sstate    unit_state_t,
        l_phase     byte,
        L_ret_code  error_t;

    TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                        @'MCEMAS: supervision_msg_s');
                        
    OUTPUT supervision_ack_s(l_mstate,l_sstate,l_phase) TO SENDER COMMENT '0002';

    DECISION(l_mstate);
    (unit_state_t_wo_c):
        TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                            @'MCEMAS: state WO: Moving to init_mce state');
        SET (NOW,master_timer);
        NEXTSTATE init_mce;
    ELSE:
        TASK write_test_log(log_type_t_dword_e_c,bytepointer(@L_ret_code),1,
                          @'MCEMAS: Moving to COLD-state');

        SET (NOW,master_timer);
        NEXTSTATE cold;
    ENDDECISION;

ENDSTATE wait_startup;
/**************************************************************************/
STATE init_mce;

INPUT master_timer;
    TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                        @'MCEMAS: master_timer'); 
      
    DECISION serv_add_done;
    (F):
        TASK serv_add_done := add_own_services();   /*Register for own service to NASEVA*/
    ENDDECISION;   
    
    DECISION subscription_done;
    (/= success_ec):    
        TASK subscription_done := subscribe_state_change_events();   /*subscribe to own unit switchover*/
        DECISION subscription_done;
        (/= success_ec): 
            SET (NOW,master_timer);
            NEXTSTATE cold;         
        ENDDECISION;               
    ENDDECISION;

    TASK set_mcermi_debug_flag(T); /*YHJ*/

    TASK init_mce_for_celldata;
    TASK init_mce_for_3389;

    NEXTSTATE wait_for_pcermi_status;
    
/**************************************************************************/
INPUT supervision_msg_s(l_mstate,l_sstate,l_phase) COMMENT '0001';

    DCL
        l_mstate    unit_state_t,
        l_sstate    unit_state_t,
        l_phase     byte,
        L_ret_code  error_t;

    TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                        @'MCEMAS: supervision_msg_s');

    OUTPUT supervision_ack_s(l_mstate,l_sstate,l_phase) TO SENDER COMMENT '0002';

    DECISION(l_mstate);
    (/=unit_state_t_wo_c):
        TASK write_test_log(log_type_t_dword_e_c,bytepointer(@L_ret_code),1,
                          @'MCEMAS: Moving to COLD-state');

        SET (NOW,master_timer);
        NEXTSTATE cold;
    ENDDECISION;
    NEXTSTATE -;


ENDSTATE init_mce;

STATE wait_for_pcermi_status;

/**************************************************************************/
INPUT cerm_conf_data_req_s COMMENT '0x122e';
DCL 
    l_msg_data         msg_122f_t; 

    DECISION(init_done);
    (F):
        NEXTSTATE -;
    ENDDECISION;

    /* COMMENT by YHJ. No need to reset master timer now since it won't be set in init_mce now. */
    /* RESET (master_timer); */ 
    TASK l_msg_data.cerm_conf_data := get_cerm_conf_data__r();
    
    OUTPUT cerm_conf_data_s (l_msg_data) TO SENDER COMMENT '0x122f';
 
    DECISION G_pcermi_status;
    (/=success_ec):
        TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                           @'MCEMAS: G_pcermi_status not OK ');
        DECISION get_pce_pid();
        (/=success_ec):
            TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                               @'MCEMAS: pcermi inquiry retry failed');

            TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                                @'MCEMAS: moving to cold ');
            NEXTSTATE - COMMENT 'modify cold to - by YHJ since tii_req_s should be received even pcerm not up, but cold can not receive tii_req_s';
        ENDDECISION;
    ENDDECISION;

    TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                        @'MCEMAS: Ready to work');
NEXTSTATE working;

/**************************************************************************/
INPUT supervision_msg_s( mstate, sstate, phase );
DCL
    mstate              unit_state_t,    /*      unit mainstate (funstcgx) */
    sstate              unit_state_t,    /*      unit substate (funstcgx)  */
    phase               byte;            /*      restart phases            */
 
    TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                        @'MCEMAS: wait_for_pcermi_status: supervision_msg_s');
                        
    OUTPUT supervision_ack_s( mstate, sstate, phase ) TO SENDER;

    DECISION(mstate);
    (/= unit_state_t_wo_c):
        TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                            @'MCEMAS: MCEMAS: Moving to COLD-state');
        SET (NOW,master_timer);
        NEXTSTATE cold;
    ENDDECISION;

    NEXTSTATE -;   
    
/**************************************************************************/
/* Funcationality previously: go to cold state if have not received "cerm_conf_data_req_s" during conf_data_wait_time__c. But after 
3389 feature is added, still keep stay in this state to wait "tii_req_s", so comment code below. */
/*
INPUT master_timer;
    TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                        @'MCEMAS: wait_for_pcermi_status: master_timer');
    
    TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                        @'MCEMAS: wait_for_pcermi_status: moving to cold');
NEXTSTATE -;   COMMENT 'change cold to - since tii_req_s should be received even pcerm not up, but cold can not receive tii_req_s by YHJ'; 
*/
ENDSTATE wait_for_pcermi_status;

/**************************************************************************/
/*******************/STATE working;/***************************************/
/**************************************************************************/
INPUT cell_first_hspa_user_s(l_msg_data) COMMENT '0x0FC7';
    DCL 
       l_msg_data               msg_0fc7_t,
       l_timestamp              calendar_time_t,
       l_cp_hand_pid            pid_union_t,
       l_index                  dword := undefined_dword_c,
       l_cell_data_ptr          cell_data_ptr__t := NIL,
       l_msg_mce_data           msg_0fff_t,
       l_status                 bool := T,
       l_c1_rec                 c1file_rec_t,
       l_mce_error              error_t := success_ec,
       l_cell_state_ok          bool := T,
       l_hand_info              mce_hand__t;

    TASK l_status := copy_calendar_time_r(l_timestamp);   /* store current calendar time to l_timestamp*/
    
    TASK l_cell_data_ptr := cell_data_read__r(l_msg_data.cell_id,l_index);
    
    DECISION l_cell_data_ptr = NIL;
    (T):
        TASK l_cell_data_ptr := cell_table_add_cell__r(l_index);  /*Add record to cell table*/
        DECISION l_cell_data_ptr = NIL;
        (T):
           /*cell table full so replace existing inactive record*/
           TASK l_cell_data_ptr := find_inactive_cell_index__r(l_index);
        ENDDECISION;
    ENDDECISION;

    DECISION l_cell_data_ptr/= NIL;
    (T):  
        TASK l_cell_data_ptr->cell_id   := l_msg_data.cell_id,
             l_cell_data_ptr->dsp_index := l_msg_data.dsp_index,
             l_cell_data_ptr->l3_proid  := l_msg_data.l3_pid;

        /*YHJ: get home ICSU, maybe needs this function in my feature*/ 
        TASK l_cell_data_ptr->home_icsu := get_home_icsu_index(l_msg_data.l3_pid);

        TASK c1_rec_read_r(l_msg_data.cell_id,l_c1_rec,l_mce_error); 

        DECISION l_mce_error;
        (/=success_ec):
            TASK l_c1_rec.cell_id   := l_msg_data.cell_id,
                 l_c1_rec.timestamp := l_timestamp;
            TASK c1_rec_store_r(l_c1_rec,l_mce_error);  /*store new record to c1file*/
        ENDDECISION;
        
        DECISION l_mce_error;
        (success_ec):
            TASK cerm_get_hand_info (l_msg_data.cell_id,l_hand_info);
            DECISION l_hand_info.hand_pr_id /= 0;
            (T):
                TASK make_pid_r(l_cp_hand_pid.real_pid,
                                get_pid_computer_r(SELF),
                                mcermi_p,
                                l_hand_info.hand_pr_id,
                                0);
                DECISION l_cp_hand_pid.real_pid = NULL;
                (T):
                    CREATE mceha1(l_index);   /* Create CP hand process*/
                    TASK l_cp_hand_pid.real_pid := OFFSPRING;

                    /*init cell table value*/
                    TASK clear_internal_cell_data(l_cell_data_ptr->cell_id);
                    TASK l_cell_data_ptr->mce_hand_info.reserved           := T,
                         l_cell_data_ptr->mce_hand_info.hand_pr_id         := get_pid_process_id_r(OFFSPRING),
                         l_cell_data_ptr->mce_hand_info.cell_state         := T,
                         l_cell_data_ptr->mce_hand_info.supervision_status := supervision_status__t_undef_c,
                         l_cell_data_ptr->timestamp                        := l_timestamp,
                         l_cell_data_ptr->pcermi_report_period             := get_pcermi_report_period(),
                         l_cell_data_ptr->data_collect                     := data_collect__t_start_c;
                ELSE:
                    TASK l_cell_state_ok := l_hand_info.cell_state;
                    TASK l_cell_data_ptr->data_collect := data_collect__t_start_c;
                 ENDDECISION;
            ELSE:
                CREATE mceha1(l_index);   /* Create CP hand process*/
                TASK l_cp_hand_pid.real_pid := OFFSPRING;

                /*init cell table value*/
                TASK clear_internal_cell_data(l_cell_data_ptr->cell_id);
                TASK l_cell_data_ptr->mce_hand_info.reserved           := T,
                     l_cell_data_ptr->mce_hand_info.hand_pr_id         := get_pid_process_id_r(OFFSPRING),
                     l_cell_data_ptr->mce_hand_info.cell_state         := T,
                     l_cell_data_ptr->mce_hand_info.supervision_status := supervision_status__t_undef_c,
                     l_cell_data_ptr->pcermi_report_period             := get_pcermi_report_period(),
                     l_cell_data_ptr->data_collect                     := data_collect__t_start_c;
            ENDDECISION;

            DECISION l_cell_state_ok;
            (T):
                TASK l_msg_mce_data.mce_task   := mce_task_t_start_collect_c,
                     l_msg_mce_data.cell_id    := l_msg_data.cell_id,
                     l_msg_mce_data.dsp_index  := l_msg_data.dsp_index,
                     l_msg_mce_data.timestamp  := l_timestamp,
                     l_msg_mce_data.pcermi_pid := NULL;
                
                /*send message to CP_HAND to start data collection for the given CELL_ID*/  
                OUTPUT mce_hand_info_s(l_msg_mce_data) TO l_cp_hand_pid.real_pid COMMENT '0xFFFE';
            ENDDECISION;
        ELSE:
            TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                              @'MCEMAS: C1file record edit failed');
        ENDDECISION;
    ELSE:
        TASK write_error_log(log_type_t_empty_t_c,NIL,0,
                          @'MCEMAS: Cell table full');
    ENDDECISION;

    NEXTSTATE -;
    
/**************************************************************************/

INPUT cell_last_hspa_user_s(l_msg_data) COMMENT '0x0FD0';
    DCL 
       l_msg_data          msg_0fd0_t, 
       l_timestamp         calendar_time_t,
       l_cp_hand_pid       pid := NULL,
       l_cell_rec_ptr      cell_data_ptr__t := NIL,
       l_msg_mce_data      msg_0fff_t,
       l_status            bool := T,
       l_index             dword := undefined_dword_c;

    TASK l_cell_rec_ptr := cell_data_read__r(l_msg_data.cell_id,l_index);

    DECISION l_cell_rec_ptr /= NIL;
    (T):
        TASK l_status := copy_calendar_time_r(l_timestamp);   /* store current calendar time to l_timestamp*/
        TASK make_pid_r(l_cp_hand_pid,
                         get_pid_computer_r(SELF),
                         mcermi_p,
                         l_cell_rec_ptr->mce_hand_info.hand_pr_id,
                         0);
                         
        TASK l_cell_rec_ptr->data_collect := data_collect__t_coll_stop_c;
        DECISION l_cp_hand_pid /= NULL;
        (T):
            TASK l_msg_mce_data.mce_task   := mce_task_t_stop_collect_c,
                 l_msg_mce_data.cell_id    := l_msg_data.cell_id,
                 l_msg_mce_data.dsp_index  := undefined_byte_c,
                 l_msg_mce_data.timestamp  := l_timestamp,
                 l_msg_mce_data.pcermi_pid := NULL;
            
            OUTPUT mce_hand_info_s(l_msg_mce_data) TO l_cp_hand_pid COMMENT '';
        ENDDECISION;
    ENDDECISION;
    NEXTSTATE -;


/**************************************************************************/
INPUT cerm_conf_data_update_s(l_msg_data) COMMENT '0x128C';
DCL
    l_msg_data           msg_128c_t,
    l_conf_msg_data      msg_122f_t,
    l_pce_pid            pid,
    l_feature_on         bool:= T;
    
    TASK l_conf_msg_data.cerm_conf_data := get_cerm_conf_data__r();
        
    DECISION l_msg_data.compmask.cerm_main_flag;
    (T):
        TASK l_conf_msg_data.cerm_conf_data.cerm_main_flag := l_msg_data.cerm_conf_data.cerm_main_flag;
        DECISION l_conf_msg_data.cerm_conf_data.cerm_main_flag;
        (F):
           TASK l_feature_on := F;
        ENDDECISION;         
    ENDDECISION;
    DECISION l_msg_data.compmask.sub_flags;
    (T):
        TASK memcpy(bytepointer(@l_conf_msg_data.cerm_conf_data.sub_flags), bytepointer(@l_msg_data.cerm_conf_data.sub_flags),
                                SIZEOF(l_conf_msg_data.cerm_conf_data.sub_flags));
        DECISION l_conf_msg_data.cerm_conf_data.sub_flags.data_collecting;
        (F):
           TASK l_feature_on := F;
        ENDDECISION;
    ENDDECISION;
    DECISION l_msg_data.compmask.pcermi_data;
    (T):
        TASK memcpy(bytepointer(@l_conf_msg_data.cerm_conf_data.pcermi_data), bytepointer(@l_msg_data.cerm_conf_data.pcermi_data), 
                                SIZEOF(l_conf_msg_data.cerm_conf_data.pcermi_data));
    ENDDECISION;
    DECISION l_msg_data.compmask.counters;
    (T):
        TASK memcpy(bytepointer(@l_conf_msg_data.cerm_conf_data.counters), bytepointer(@l_msg_data.cerm_conf_data.counters), 
                                SIZEOF(l_conf_msg_data.cerm_conf_data.counters));
    ENDDECISION;
    DECISION l_msg_data.compmask.reporting_period;
    (T):
        TASK l_conf_msg_data.cerm_conf_data.reporting_period := l_msg_data.cerm_conf_data.reporting_period;
    ENDDECISION;
    DECISION l_msg_data.compmask.event_log_size;
    (T):
        TASK l_conf_msg_data.cerm_conf_data.event_log_size := l_msg_data.cerm_conf_data.event_log_size;
    ENDDECISION;
    DECISION l_msg_data.compmask.icsu_cpu_usage_th;
    (T):
        TASK l_conf_msg_data.cerm_conf_data.icsu_cpu_usage_th := l_msg_data.cerm_conf_data.icsu_cpu_usage_th;
    ENDDECISION;

    TASK cell_table_upd_conf_data__r(l_conf_msg_data.cerm_conf_data);
    
    TASK make_pid_r(l_pce_pid,log_address_t_icsux_c, pcermi_p,0,0);
    
    OUTPUT cerm_conf_data_s (l_conf_msg_data) TO l_pce_pid COMMENT '0x122f';

    DECISION l_feature_on;
    (F):
        TASK stop_all_cp_data_collect();
        /*TASK init_mce_hand_tbl();*/ /*Initialize hand_table*/
        NEXTSTATE cold;
    ENDDECISION;

NEXTSTATE -;


/**************************************************************************/
INPUT mce_hand_info_s(l_msg_data ) COMMENT '0x0FFF';

DCL
    l_msg_data     msg_0fff_t,
    l_status       bool;   

    DECISION l_msg_data.mce_task;
    (mce_task_t_hand_stop_c):       /* Hand stop indication         */
         TASK l_status := cell_table_update_cp_pid__r(l_msg_data.cell_id, 0);   /*update cell table with NULL cp hand pid*/
    ELSE:
        TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                            @'MCEHA1: Invalid TASK received');
    ENDDECISION;

    NEXTSTATE -;


/**************************************************************************/
INPUT cerm_conf_data_req_s COMMENT '0x122e';
DCL 
    l_msg_data         msg_122f_t,
    l_tbl_index        dword := 0,
    l_msg_mce_data     msg_0fff_t,
    l_cell_rec         mce_cell_table__t,
    l_status           bool := F,
    l_index            dword := undefined_dword_c,
    l_mce_hand_tbl     mce_hand_tbl__t,
    l_cp_hand_pid      pid;
     
    TASK l_msg_data.cerm_conf_data := get_cerm_conf_data__r();

    OUTPUT cerm_conf_data_s (l_msg_data) TO SENDER COMMENT '0x122f';

    TASK get_hand_info_for_all_cells(l_mce_hand_tbl);

    WHILE (l_tbl_index < l_mce_hand_tbl.count);

        TASK l_index := find_cell_record_for_proid__r(l_mce_hand_tbl.mce_hand_info(l_tbl_index).hand_pr_id,l_cell_rec);
        
        TASK l_msg_mce_data.mce_task    := mce_task_t_start_collect_c,
             l_msg_mce_data.cell_id     := l_cell_rec.cell_id,
             l_msg_mce_data.dsp_index   := l_cell_rec.dsp_index,
             l_msg_mce_data.pcermi_pid  := SENDER;

        TASK l_status := copy_calendar_time_r(l_msg_mce_data.timestamp);

        TASK make_pid_r(l_cp_hand_pid,
                        get_pid_computer_r(SELF),
                        mcermi_p,
                        l_mce_hand_tbl.mce_hand_info(l_tbl_index).hand_pr_id,
                        0); 

            /*send message to CP_HAND to start data collection for the given CELL_ID*/
            OUTPUT mce_hand_info_s(l_msg_mce_data) TO l_cp_hand_pid COMMENT '0xFFFE';
        TASK l_tbl_index := l_tbl_index + 1;
    ENDWHILE;

NEXTSTATE -;


/**************************************************************************/
INPUT cell_state_notification_s(l_msg_data) COMMENT '0xDA71';

DCL 
    l_msg_data               msg_da71_t,
    l_timestamp              calendar_time_t,
    l_msg_mce_data           msg_0fff_t,
    l_status                 bool,
    l_mce_hand               mce_hand__t,
    l_cp_hand_pid            pid;
    
    TASK cerm_get_hand_info(l_msg_data.cell_id,l_mce_hand);

    DECISION l_mce_hand.reserved;
    (T):
        TASK l_status := copy_calendar_time_r(l_timestamp);   /* store current calendar time to l_timestamp*/

        TASK make_pid_r(l_cp_hand_pid,
                         get_pid_computer_r(SELF),
                         mcermi_p,
                         l_mce_hand.hand_pr_id,
                         0);

        DECISION l_msg_data.cell_state = 1;
        (T):
           TASK l_msg_mce_data.mce_task := mce_task_t_cell_unavailable_c,
                l_msg_mce_data.cell_id  := l_msg_data.cell_id,
                l_msg_mce_data.dsp_index := 0,
                l_msg_mce_data.timestamp := l_timestamp;

            TASK l_mce_hand.cell_state := F;

            TASK cerm_update_hand_info(l_msg_data.cell_id,l_mce_hand);

            OUTPUT mce_hand_info_s(l_msg_mce_data) TO l_cp_hand_pid COMMENT '';
        ELSE:
           TASK l_msg_mce_data.mce_task := mce_task_t_cell_available_c,
                l_msg_mce_data.cell_id  := l_msg_data.cell_id,
                l_msg_mce_data.dsp_index := 0,
                l_msg_mce_data.timestamp := l_timestamp;

            TASK l_mce_hand.cell_state := T;
            
            TASK cerm_update_hand_info(l_msg_data.cell_id,l_mce_hand);

            OUTPUT mce_hand_info_s(l_msg_mce_data) TO l_cp_hand_pid COMMENT '';
        ENDDECISION;
    ELSE:
        TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                          @'MCEMAS: data collection not ongoing for the Cell');
    ENDDECISION;


NEXTSTATE -;

/**************************************************************************/
  
INPUT supervision_msg_s( mstate, sstate, phase );
DCL
    mstate              unit_state_t,    /*      unit mainstate (funstcgx) */
    sstate              unit_state_t,    /*      unit substate (funstcgx)  */
    phase               byte,            /*      restart phases            */
    l_mce_hand_tbl      mce_hand_tbl__t;

    OUTPUT supervision_ack_s( mstate, sstate, phase ) TO SENDER;

    TASK get_hand_info_for_all_cells(l_mce_hand_tbl);
    
    DECISION l_mce_hand_tbl.next_supervise_index; 
    (undefined_dword_c):
          /*This signifies that there are no hand supervision ongoing */
          /*Send hand_supervision_msg_s to self for initiating hand
            supervision*/
          DECISION l_mce_hand_tbl.count >0;
          (T):
              TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                               @'MCEMAS: supervision_msg_s');
              TASK l_mce_hand_tbl.next_supervise_index := 0;
              TASK update_supervision_info(l_mce_hand_tbl.next_supervise_index);
              OUTPUT hand_supervision_msg_s TO SELF;
          ENDDECISION;
     ENDDECISION;

    NEXTSTATE -;  

/********************************************************************/
/********************************************************************/
/*    INPUT     hand_supervision_msg_s                              */
/*    NUMBER    0x7816                                              */
/*    STATE     active                                              */
/*    SERVICE                                                       */
/*    SENDER    MCE Master                                          */
/*    OTHER                                                         */
/*                                                                  */
/*                                                                  */
/*    AUTHOR/REVISED BY :                                           */
/********************************************************************/
/********************************************************************/
INPUT hand_supervision_msg_s ;
DCL
    L_num_hand  dword,
    L_msg_sent  bool;


    /*initiate the supervision for first 10 mcermi CP hand or less
      from MCE Hand table*/
    TASK L_num_hand := 10;
        
    TASK L_msg_sent := send_supervision_msg(L_num_hand);
    DECISION L_msg_sent;
    (T):
                TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                          @'MCEMAS: hand_supervision_msg_s');
        SET(NOW + hand_refresh_wait_time__c,t_hand_supervision);
    ENDDECISION;
    NEXTSTATE - ;
/********************************************************************/
/********************************************************************/
/*    INPUT     hand_supervision_ack_s                              */
/*    NUMBER    0x7817                                              */
/*    STATE     active                                              */
/*    SERVICE                                                       */
/*    SENDER    MCEHA1 Hand                                         */
/*    OTHER                                                         */
/*                                                                  */
/*                                                                  */
/*    AUTHOR/REVISED BY :                                           */
/********************************************************************/
/********************************************************************/

INPUT hand_supervision_ack_s;
DCL
    l_tbl_index       word := 0,
    l_msg_sent        bool,
    l_num_hand        dword,
    l_cell_rec        mce_cell_table__t,
    l_ctrl_pid        pid_union_t,
    l_status          bool := F;

    /*Mark the supervision status of SENDER as resp_received_c in supervision information*/
    TASK l_ctrl_pid.real_pid := SENDER; 
       
    TASK l_tbl_index := find_cell_record_for_proid__r(l_ctrl_pid.pid_struct.process_id,l_cell_rec);
     
    DECISION l_tbl_index /= undefined_dword_c;
    (T):
        TASK l_cell_rec.mce_hand_info.supervision_status := supervision_status__t_rp_rcv_c;

        TASK write_test_log(log_type_t_empty_t_c,NIL,0,                  
                          @'MCEMAS: hand_supervision_msg_s'); 
        TASK l_status := cell_table_update_record__r(l_cell_rec,l_tbl_index);     
    ENDDECISION;
    
    TASK l_num_hand := 1;
    TASK l_msg_sent := send_supervision_msg(l_num_hand);
    DECISION l_msg_sent;
    (T):
        SET(NOW + hand_refresh_wait_time__c,t_hand_supervision);
    ENDDECISION;

    NEXTSTATE -;
    
/**************************************************************************/
INPUT t_hand_supervision;
DCL
    L_status            bool,
    L_failed_pid_list   failed_pid_list__t,
    L_restart_status   error_t,
    L_index             dword;


    /*check the supervision status of all CP hand
      and restart all those hands which fails to
      respond to hand supervision message*/
    TASK L_status := check_supervision_status(L_failed_pid_list);
    DECISION L_status;
    (F):
        /*MCERMI master stops the MCE-CP hand and does the
          similar handling as in MCE-CP hand crash scenario */
        TASK L_index := 0;
        WHILE L_index < L_failed_pid_list.num_of_pid;
            TASK write_test_log(log_type_t_dword_e_c,bytepointer(@L_failed_pid_list.mcecp_pid(L_index).real_pid),1,
                              @'MCEMAS: Crashed CP PID is...');

            TASK L_status := start_hand_crash_proc(L_failed_pid_list.mcecp_pid(L_index));
            DECISION L_status;
            (F):
                TASK write_test_log( log_type_t_dword_e_c, bytepointer(@L_failed_pid_list.mcecp_pid(L_index).pid_struct.process_id),1,
                                   @'MCEMAS: Crash Hand removal fails ');
            ENDDECISION;
            /*kill the hand*/
            TASK L_restart_status := restart_hand(L_failed_pid_list.mcecp_pid(L_index).pid_struct.process_id);
            TASK L_index := L_index + 1;
        ENDWHILE;
    ENDDECISION;
    CALL init_supervision_info;
    NEXTSTATE -; 

INPUT ste_config_req__s(pcermi_pid) COMMENT '0x9111';
DCL 
    pcermi_pid              pid;

    TASK pcermi_pid := SENDER;

    OUTPUT  ste_config_req__s(pcermi_pid) TO G_ste_pid.real_pid COMMENT '0x9111';
    
NEXTSTATE -;

/******************************CEHEXT message*****************************************/
INPUT mcerm_data_collect_req__s(ceh_pid, cell_id, collect_state) COMMENT '0x9100';
DCL 
    ceh_pid         pid,
    cell_id         c_id_t,
    collect_state   data_collect__t; 

    TASK ceh_pid := SENDER;

    OUTPUT  mcerm_data_collect_req__s(ceh_pid, cell_id, collect_state) TO G_ste_pid.real_pid COMMENT '0x9100';
    
    NEXTSTATE -;

INPUT mcerm_counter_data_req__s(ceh_pid, cell_id) COMMENT '0x9102';
DCL 
    ceh_pid         pid,
    cell_id         c_id_t;

    TASK ceh_pid := SENDER;

    OUTPUT  mcerm_counter_data_req__s(ceh_pid, cell_id) TO G_ste_pid.real_pid COMMENT '0x9102';
    
    NEXTSTATE -;

INPUT c1file_update_period__s(c1file_update_period) COMMENT '0x9109';
DCL 
    c1file_update_period         dword,
    l_next_update_period         dword;

    DECISION get_mcermi_debug_flag();
    (T):
        TASK c1file_update_period := c1file_update_period * 60 * ticket_per_second__c;
        TASK set_c1file_update_period(c1file_update_period);
        RESET(t_c1file_update_timer);
        TASK l_next_update_period := get_c1file_update_timer_value();
        SET (NOW + l_next_update_period , t_c1file_update_timer);
        
    ENDDECISION;

NEXTSTATE -;

INPUT ste_config__s(mcermi_debug_flag) COMMENT '0x9110';
DCL 
    mcermi_debug_flag                   bool;

    OUTPUT  ste_config__s(mcermi_debug_flag) TO G_ste_pid.real_pid COMMENT '0x9110';
    
NEXTSTATE -;

INPUT ste_config_inq__s(ceh_pid) COMMENT '0x9112';
DCL 
    ceh_pid              pid;

    TASK ceh_pid := SENDER;

    OUTPUT  ste_config_inq__s(ceh_pid) TO G_ste_pid.real_pid COMMENT '0x9112';
    
NEXTSTATE -;

INPUT pcermi_report_period__s(pcermi_report_period) COMMENT '0x9114';
DCL 
    pcermi_report_period         dword;

    DECISION get_mcermi_debug_flag();
    (T):
        OUTPUT  pcermi_report_period__s(pcermi_report_period) TO G_ste_pid.real_pid COMMENT '0x9114';
    ENDDECISION;

NEXTSTATE -;

INPUT c1file_update_period_inq__s(ceh_pid) COMMENT '0x9115';
DCL 
    ceh_pid              pid;

    TASK ceh_pid := SENDER;

    OUTPUT  c1file_update_period_inq__s(ceh_pid) TO G_ste_pid.real_pid COMMENT '0x9115';

NEXTSTATE -;

INPUT pcermi_report_period_inq__s(ceh_pid) COMMENT '0x9116';
DCL 
    ceh_pid              pid;

    TASK ceh_pid := SENDER;

    OUTPUT  pcermi_report_period_inq__s(ceh_pid) TO G_ste_pid.real_pid COMMENT '0x9116';

NEXTSTATE -;

ENDSTATE working;

STATE *;
/**************************************************************************/
INPUT c_test_msg_s(l_test_log,l_mod_test,?) COMMENT '#TNCOV:ERROR';

    DCL
        l_test_log                  byte,
        l_mod_test                  byte,
        /*  PR 86821ESPE01: MCERMI uses unnecessary high amount of memory, move the "l_c1_rec_list"*/
        /*  l_c1_rec_list               ce1_rec_list__t, */  
        l_num_rec                   dword := 0,
        l_status                    error_t,
        l_index                     word := 0,
        l_msg_mce_data              msg_0fff_t,
        l_hand_info                 mce_hand__t,
        l_pid                       pid;
        
    DECISION l_test_log;
    (0x01):
         TASK print_whole_cell_table();         
    /*   PR 86821ESPE01
    (0x02):
        TASK c1_all_rec_read_r(l_c1_rec_list,l_num_rec,l_status);
        TASK write_error_log(log_type_t_dword_t_c,bytepointer(@l_num_rec),1,@'MCEMAS: c1_all_rec_read_r1');
        TASK l_index := 0;
        WHILE l_index < l_num_rec;
            TASK write_error_log(log_type_t_word_t_c,bytepointer(@l_c1_rec_list(l_index).c1fil.cell_id),1,@'MCEMAS: cell_id');
            TASK l_index := l_index + 1;
        ENDWHILE;  
   */  
    (0x03):
        TASK set_test_log_variables(1);
    (0x04):
        TASK set_test_log_variables(0);
    (0x05):
        TASK cerm_get_hand_info (dword(l_mod_test),l_hand_info);
        TASK l_msg_mce_data.mce_task   := mce_task_t_hand_stop_c,
             l_msg_mce_data.cell_id    := c_id_t(l_mod_test);
        DECISION l_hand_info.hand_pr_id /= 0;
        (T):
            TASK make_pid_r(l_pid,
                            get_pid_computer_r(SELF),
                            mcermi_p,
                            l_hand_info.hand_pr_id,
                            0);
            OUTPUT mce_hand_info_s(l_msg_mce_data) TO l_pid COMMENT '0xFFFE';
        ENDDECISION;
    (0x06):
          RESET (t_c1file_update_timer);
          SET (NOW + 0, t_c1file_update_timer);
    ELSE: 
        TASK write_error_log(log_type_t_byte_t_c,bytepointer(@l_test_log),1,@'MCEMAS: Testing info received');
    ENDDECISION;
    NEXTSTATE -;


INPUT t_c1file_update_timer;
DCL 
    l_update_and_close      bool := F,
    l_mce_hand_tbl          mce_hand_tbl__t,
    l_c1_rec                c1file_rec_t,
    l_status                error_t,
    status                  bool := F,
    l_tbl_index             dword := 0,
    l_timestamp             calendar_time_t,
    l_next_update_period    dword := 0;
    
    TASK get_hand_info_for_all_cells(l_mce_hand_tbl);
    TASK memset(bytepointer(@l_timestamp), 0xff, sizeof(l_timestamp));

    WHILE (l_tbl_index < l_mce_hand_tbl.count);
        TASK c1_rec_read_r(l_mce_hand_tbl.cell_id_list(l_tbl_index),l_c1_rec, l_status);
        DECISION l_status = success_ec;
        (T):
            DECISION process_data_for_c1file_update(l_c1_rec);
            (T):
                TASK status := copy_calendar_time_r(l_timestamp);
                TASK l_c1_rec.timestamp := l_timestamp;
                TASK c1_rec_store_r(l_c1_rec, l_status); 
                DECISION l_status;
                (/= success_ec):
                    /*try one more time after 5 sec*/
                    TASK retry_after_5_sec_time();
                    TASK c1_rec_store_r(l_c1_rec, l_status);
                ENDDECISION;
            ENDDECISION;
        ENDDECISION;
        TASK clear_internal_cell_data(l_mce_hand_tbl.cell_id_list(l_tbl_index));
        TASK l_tbl_index := l_tbl_index + 1;
    ENDWHILE;

    TASK update_c1file_and_close(l_update_and_close);  /*just update c1file*/
    TASK l_next_update_period := get_c1file_update_timer_value();

    SET (NOW + l_next_update_period, t_c1file_update_timer);

NEXTSTATE -;


/**************************************************************************/
INPUT hand_stopped_s COMMENT '2070';

    DCL
        l_hand_pid              pid_union_t,
        l_status                bool := F,
        l_cell_rec              mce_cell_table__t,
        l_tbl_index             dword := 0;

    TASK l_hand_pid.real_pid := SENDER;
    TASK l_tbl_index := find_cell_record_for_proid__r(l_hand_pid.pid_struct.process_id,l_cell_rec);
    DECISION l_tbl_index /= undefined_dword_c;
    (T):
        TASK l_cell_rec.mce_hand_info.reserved := F,
             l_cell_rec.mce_hand_info.hand_pr_id := 0;
        TASK l_cell_rec.data_collect := data_collect__t_coll_stop_c;

        TASK write_test_log(log_type_t_empty_t_c,NIL,0,
                          @'MCEMAS: hand_stopped_s');
        TASK l_status := cell_table_update_record__r(l_cell_rec,l_tbl_index);   /*update cell table with NULL cp hand pid*/
    ENDDECISION;

    NEXTSTATE -;

ENDSTATE *;
/**************************************************************************/
STATE * (wait_startup,cold);
/**************************************************************************/
INPUT prb_restart_notice_s(l_fam_id,l_reason);
DCL
    l_fam_id             family_id_t,
    l_reason             error_t,
    l_tbl_index          dword,
    l_msg_bfaa           msg_bfaa_t,
    l_mce_hand_tbl       mce_hand_tbl__t,
    l_hand_pid           pid;
    

    DECISION l_fam_id;
    (pcermi_p):
        TASK l_tbl_index := 0;
        TASK l_msg_bfaa.crashed_pid.real_pid := NULL;
        TASK l_msg_bfaa.crashed_pid.pid_struct.family := pcermi_p;

        TASK get_hand_info_for_all_cells(l_mce_hand_tbl);
            
        WHILE (l_tbl_index < l_mce_hand_tbl.count);
            DECISION l_mce_hand_tbl.mce_hand_info(l_tbl_index).reserved;
            (T):
                TASK make_pid_r(l_hand_pid,get_pid_computer_r(SELF),mcermi_p,l_mce_hand_tbl.mce_hand_info(l_tbl_index).hand_pr_id,0);
               
                OUTPUT rnc_hand_released_s(l_msg_bfaa) TO l_hand_pid;
            ENDDECISION;
            TASK l_tbl_index := l_tbl_index + 1;
        ENDWHILE;
    ENDDECISION;
    NEXTSTATE -;

/**************************************************************************/
INPUT re_unit_restart_imminent_s(l_unit_it.ttype,
                                 l_unit_it.index,
                                 l_activation,
                                 l_rst_width,
                                 l_cntrl_status) COMMENT 'E30F';

    DCL
        l_unit_it               unit_it_t,
        l_activation            cmd_act_t,
        l_rst_width             restart_width_t,
        l_cntrl_status          cmd_ctrl_t,
        l_update_and_close      bool := F;

    TASK l_update_and_close := T;
    TASK update_c1file_and_close(l_update_and_close); /*update c1file and close*/

    TASK handle_re_unit_restart_imminent();

    NEXTSTATE -;

/**************************************************************************/
INPUT process_frozen_by_dmxrte_s COMMENT '8515';

    DCL
        l_frozen_hand           pid_union_t,
        L_status                bool,
        L_restart_status        error_t;

    TASK l_frozen_hand.real_pid := SENDER;
    TASK L_restart_status := restart_hand(l_frozen_hand.pid_struct.process_id);
    TASK L_status := start_hand_crash_proc(l_frozen_hand);
    DECISION L_status;
    (F):
        TASK write_test_log(log_type_t_byte_e_c,
                            bytepointer(@l_frozen_hand),
                            SIZEOF(l_frozen_hand),
                            @'MCEMAS: Hand not found (8515)');
    ENDDECISION;

    NEXTSTATE -;

ENDSTATE * (wait_startup,cold);

/**************************************************************************/
STATE * (wait_startup, cold, init_mce);
/**************************************************************************/
INPUT aggregat_dsp_call_s(?);
  DECISION(np_recov_init_done);
  (T):
       OUTPUT INPUT TO mceha2_pid.real_pid;
       NEXTSTATE -;
  ENDDECISION;

  NEXTSTATE -;
  
/**************************************************************************/
/*for debug*/
INPUT tii_req_test__s(call_failures);
    DCL 
        call_failures call_failures__t,
        call_failure_aggregated call_failure_aggregated_t;

    TASK memset(bytepointer(@call_failure_aggregated), 0 , sizeof(call_failure_aggregated_t));
    TASK write_test_log(log_type_t_empty_t_c,NIL,0, @'MCEMAS: tii_req_test__s1');
    TASK call_failure_aggregated.dw_length := 3;
    TASK call_failure_aggregated.call_failure(0) := call_failures.st(0);
    TASK call_failure_aggregated.call_failure(1) := call_failures.st(1);
    TASK call_failure_aggregated.call_failure(2) := call_failures.st(2);
    OUTPUT aggregat_dsp_call_s(call_failure_aggregated) TO SELF;
    TASK write_test_log(log_type_t_empty_t_c,NIL,0, @'MCEMAS: tii_req_test__s2');

    NEXTSTATE -;
    
ENDSTATE * (wait_startup, cold, init_mce);


/**************************************************************************/
STATE cold;


/**************************************************************************/
INPUT cerm_conf_data_req_s COMMENT '0x122e';
DCL 
    l_msg_data         msg_122f_t;

    TASK l_msg_data.cerm_conf_data := get_cerm_conf_data__r();

    OUTPUT cerm_conf_data_s (l_msg_data) TO SENDER COMMENT '0x122f';

NEXTSTATE -;



/**************************************************************************/
INPUT cerm_conf_data_update_s(l_msg_data) COMMENT '0x128C';
DCL
    l_msg_data           msg_128c_t,
    l_conf_msg_data      msg_122f_t,
    l_pce_pid            pid,
    l_feature_on         bool:= F;
    
    TASK l_conf_msg_data.cerm_conf_data := get_cerm_conf_data__r();
        
    DECISION l_msg_data.compmask.cerm_main_flag;
    (T):
        TASK l_conf_msg_data.cerm_conf_data.cerm_main_flag := l_msg_data.cerm_conf_data.cerm_main_flag;
        DECISION l_conf_msg_data.cerm_conf_data.cerm_main_flag;
        (T):
           TASK l_feature_on := T;
        ENDDECISION;         
    ENDDECISION;
    DECISION l_msg_data.compmask.sub_flags;
    (T):
        TASK memcpy(bytepointer(@l_conf_msg_data.cerm_conf_data.sub_flags), bytepointer(@l_msg_data.cerm_conf_data.sub_flags), 
                                SIZEOF(l_conf_msg_data.cerm_conf_data.sub_flags));
        DECISION l_conf_msg_data.cerm_conf_data.sub_flags.data_collecting;
        (T):
           TASK l_feature_on := T;
        ENDDECISION;
    ENDDECISION;
    DECISION l_msg_data.compmask.pcermi_data;
    (T):
        TASK memcpy(bytepointer(@l_conf_msg_data.cerm_conf_data.pcermi_data), bytepointer(@l_msg_data.cerm_conf_data.pcermi_data), 
                                SIZEOF(l_conf_msg_data.cerm_conf_data.pcermi_data));
    ENDDECISION;
    DECISION l_msg_data.compmask.counters;
    (T):
        TASK memcpy(bytepointer(@l_conf_msg_data.cerm_conf_data.counters), bytepointer(@l_msg_data.cerm_conf_data.counters), 
                                SIZEOF(l_conf_msg_data.cerm_conf_data.counters));
    ENDDECISION;
    DECISION l_msg_data.compmask.reporting_period;
    (T):
        TASK l_conf_msg_data.cerm_conf_data.reporting_period := l_msg_data.cerm_conf_data.reporting_period;
    ENDDECISION;
    DECISION l_msg_data.compmask.event_log_size;
    (T):
        TASK l_conf_msg_data.cerm_conf_data.event_log_size := l_msg_data.cerm_conf_data.event_log_size;
    ENDDECISION;    
    DECISION l_msg_data.compmask.icsu_cpu_usage_th;
    (T):
        TASK l_conf_msg_data.cerm_conf_data.icsu_cpu_usage_th := l_msg_data.cerm_conf_data.icsu_cpu_usage_th;
    ENDDECISION;

    TASK cell_table_upd_conf_data__r(l_conf_msg_data.cerm_conf_data);
    
     DECISION l_feature_on;
     (T):
         TASK make_pid_r(l_pce_pid,log_address_t_icsux_c, pcermi_p,0,0);
         OUTPUT cerm_conf_data_s (l_conf_msg_data) TO l_pce_pid COMMENT '0x122f';

         DECISION init_done AND G_pcermi_status = success_ec;
         (T):
             NEXTSTATE working;
         ELSE: 
             SET (NOW,master_timer);
             NEXTSTATE init_mce;
         ENDDECISION;
     ENDDECISION;
     
NEXTSTATE -;

/**************************************************************************/
INPUT supervision_msg_s(l_mstate,l_sstate,l_phase) COMMENT '0001';

    DCL
        l_mstate                    unit_state_t,
        l_sstate                    unit_state_t,
        l_phase                     byte,
        l_cerm_conf_data            cerm_conf_data_t;

    OUTPUT supervision_ack_s(l_mstate,l_sstate,l_phase) TO SENDER COMMENT '0002';

    TASK l_cerm_conf_data := get_cerm_conf_data__r(); 
    
    DECISION(l_mstate);
    (unit_state_t_wo_c):
        DECISION l_cerm_conf_data.cerm_main_flag;
        (T):
            DECISION init_done AND G_pcermi_status = success_ec;
            (T):
                NEXTSTATE working;
            ELSE: 
                TASK write_test_log(log_type_t_empty_t_c,NIL,0,@'MCEMAS: Moving to WORKING-state');
                SET (NOW,master_timer);
                NEXTSTATE init_mce;
            ENDDECISION;
        ENDDECISION;
    ENDDECISION;

    NEXTSTATE -;

/**************************************************************************/
INPUT re_state_change_executed_s(?,?,?,l_mstate,?,?) COMMENT 'E31D';

    DCL
        l_mstate                    unit_state_t;
   
    DECISION(l_mstate);
    (unit_state_t_wo_c):
        TASK write_test_log(log_type_t_empty_t_c,NIL,0,@'MCEMAS: Moving to WORKING-state');
        SET (NOW,master_timer);
        NEXTSTATE init_mce;
    ENDDECISION;

    NEXTSTATE -;

/**************************************************************************/
INPUT re_unit_restart_imminent_s(?,?,?,?,?) COMMENT 'E30F';
    /* just eat message */
    NEXTSTATE -;

/**************************************************************************/
INPUT master_timer;

    NEXTSTATE -;

ENDSTATE cold;

ENDPROCESS mcemas;
